<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能 表3-1: cd 快捷键    快捷键 运行结果    cd 更改工作目录到你的家目录。   cd - 更改工作目录到先前的工作目录。   cd ~user_name 更改工作目录到用户家目录。例如， cd ~bob 会更改工作目录到用户“bob”的家目录。   大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“">
<meta property="og:type" content="article">
<meta property="og:title" content="The Linux Command Line">
<meta property="og:url" content="https://wanghuaren.github.io/2018/10/22/page22/index.html">
<meta property="og:site_name" content="on my way">
<meta property="og:description" content="图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能 表3-1: cd 快捷键    快捷键 运行结果    cd 更改工作目录到你的家目录。   cd - 更改工作目录到先前的工作目录。   cd ~user_name 更改工作目录到用户家目录。例如， cd ~bob 会更改工作目录到用户“bob”的家目录。   大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-10-22T07:45:58.000Z">
<meta property="article:modified_time" content="2024-01-08T10:32:14.983Z">
<meta property="article:author" content="wnghuaren">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>The Linux Command Line</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2020/04/01/page23/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2018/07/17/page21/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://wanghuaren.github.io/2018/10/22/page22/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://wanghuaren.github.io/2018/10/22/page22/&text=The Linux Command Line"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://wanghuaren.github.io/2018/10/22/page22/&is_video=false&description=The Linux Command Line"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=The Linux Command Line&body=Check out this article: https://wanghuaren.github.io/2018/10/22/page22/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://wanghuaren.github.io/2018/10/22/page22/&name=The Linux Command Line&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://wanghuaren.github.io/2018/10/22/page22/&t=The Linux Command Line"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        The Linux Command Line
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">wnghuaren</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-10-22T07:45:58.000Z" class="dt-published" itemprop="datePublished">2018-10-22</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能</p>
<p>表3-1: cd 快捷键</p>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">运行结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cd</td>
<td align="left">更改工作目录到你的家目录。</td>
</tr>
<tr>
<td align="left">cd -</td>
<td align="left">更改工作目录到先前的工作目录。</td>
</tr>
<tr>
<td align="left">cd ~user_name</td>
<td align="left">更改工作目录到用户家目录。例如， cd ~bob 会更改工作目录到用户“bob”的家目录。</td>
</tr>
</tbody></table>
<p>大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令，包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然，许多命令也允许把多个短选项串在一起使用。下面这例子，ls 命令有两个选项，“l” 选项产生长格式输出，“t”选项按文件修改时间的先后来排序。加上长选项 “–reverse”，则结果会以相反的顺序输出</p>
<p>表 4-1: ls 命令选项</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">长选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-a</td>
<td align="left">–all</td>
<td align="left">列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left">–directory</td>
<td align="left">通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。</td>
</tr>
<tr>
<td align="left">-F</td>
<td align="left">–classify</td>
<td align="left">这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个’&#x2F;‘字符。</td>
</tr>
<tr>
<td align="left">-h</td>
<td align="left">–human-readable</td>
<td align="left">当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left"></td>
<td align="left">以长格式显示结果。</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">–reverse</td>
<td align="left">以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。</td>
</tr>
<tr>
<td align="left">-S</td>
<td align="left"></td>
<td align="left">命令输出结果按照文件大小来排序。</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left"></td>
<td align="left">按照修改时间来排序。</td>
</tr>
</tbody></table>
<p>file filename 确定文件类型</p>
<p>everything is a file. 一切皆文件</p>
<p>表5-1: 通配符</p>
<table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配任意多个字符（包括零个或一个）</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配任意一个字符（不包括零个）</td>
</tr>
<tr>
<td align="left">[characters]</td>
<td align="left">匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td align="left">[!characters]</td>
<td align="left">匹配任意一个不是字符集中的字符</td>
</tr>
<tr>
<td align="left">[[:class:]]</td>
<td align="left">匹配任意一个属于指定字符类中的字符</td>
</tr>
</tbody></table>
<p>表5-2: 普遍使用的字符类</p>
<table>
<thead>
<tr>
<th align="left">字符类</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[:alnum:]</td>
<td align="left">匹配任意一个字母或数字</td>
</tr>
<tr>
<td align="left">[:alpha:]</td>
<td align="left">匹配任意一个字母</td>
</tr>
<tr>
<td align="left">[:digit:]</td>
<td align="left">匹配任意一个数字</td>
</tr>
<tr>
<td align="left">[:lower:]</td>
<td align="left">匹配任意一个小写字母</td>
</tr>
<tr>
<td align="left">[:upper:]</td>
<td align="left">匹配任意一个大写字母</td>
</tr>
</tbody></table>
<p>mkdir directory…</p>
<p>注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面，这意味着那个参数可以重复</p>
<p>表5-4: cp 选项</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-a, –archive</td>
<td align="left">复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。</td>
</tr>
<tr>
<td align="left">-i, –interactive</td>
<td align="left">在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。</td>
</tr>
<tr>
<td align="left">-r, –recursive</td>
<td align="left">递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。</td>
</tr>
<tr>
<td align="left">-u, –update</td>
<td align="left">当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</td>
</tr>
<tr>
<td align="left">-v, –verbose</td>
<td align="left">显示翔实的命令操作信息</td>
</tr>
</tbody></table>
<p>表5-6: mv 选项</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i –interactive</td>
<td align="left">在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。</td>
</tr>
<tr>
<td align="left">-u –update</td>
<td align="left">当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。</td>
</tr>
<tr>
<td align="left">-v –verbose</td>
<td align="left">当操作 mv 命令时，显示翔实的操作信息。</td>
</tr>
</tbody></table>
<p>表5-8: rm 选项</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-i, –interactive</td>
<td align="left">在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件</td>
</tr>
<tr>
<td align="left">-r, –recursive</td>
<td align="left">递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td>
</tr>
<tr>
<td align="left">-f, –force</td>
<td align="left">忽视不存在的文件，不显示提示信息。这选项覆盖了“–interactive”选项。</td>
</tr>
<tr>
<td align="left">-v, –verbose</td>
<td align="left">在执行 rm 命令时，显示翔实的操作信息。</td>
</tr>
</tbody></table>
<p>对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。</p>
<p>bash 有一个内建的帮助工具，可供每一个 shell 内建命令使用。输入“help”，接着是 shell 内部命令名。例如：help cd</p>
<p>注意表示法: 出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符表示互斥选项。在上面 cd 命令的例子中：cd [-L|-P] [dir]</p>
<p>许多可执行程序支持一个 –help 选项，这个选项是显示命令所支持的语法和选项说明。例如：mkdir –help</p>
<p>许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页(man page)。一个特殊的叫做 man 的分页程序，可用来浏览他们。它是这样使用的：man program</p>
<p>表6-1: 手册页的组织形式</p>
<table>
<thead>
<tr>
<th align="left">章节</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">用户命令</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">程序接口内核系统调用</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">C 库函数程序接口</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">特殊文件，比如说设备结点和驱动程序</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">文件格式</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">游戏娱乐，如屏幕保护程序</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">其他方面</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">系统管理员命令</td>
</tr>
</tbody></table>
<p>有时候，我们需要查看参考手册的特定章节，从而找到我们需要的信息。如果我们要查找一种文件格式，而同时它也是一个命令名时，这种情况尤其正确：man 5 passwd</p>
<p>alias name&#x3D;’string’ 在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后，这个命令别名可以使用在任何地方</p>
<p>如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：&gt; empty.txt</p>
<p>shell 使用文件描述符提供了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种表示法来重定向标准错误：ls -l &#x2F;bin&#x2F;usr 2&gt; ls-error.txt</p>
<p>可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法，在旧版本 shell 中也有效：ls -l &#x2F;bin&#x2F;usr &gt; ls-output.txt 2&gt;&amp;1，使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2&gt;&amp;1。</p>
<p>现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。ls -l &#x2F;bin&#x2F;usr &amp;&gt; ls-output.txt</p>
<p>我们不想要一个命令的输出结果，只想把它们扔掉。这种情况尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”&#x2F;dev&#x2F;null”的特殊文件，为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：ls -l &#x2F;bin&#x2F;usr 2&gt; &#x2F;dev&#x2F;null</p>
<p>cat 经常被用来显示简短的文本文件。因为 cat 可以接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离），我们想把它们连起来。如果文件命名为：movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099，我们能用这个命令把它们连接起来：cat movie.mpeg.0* &gt; movie.mpeg</p>
<p>wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。</p>
<p>grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</p>
<p>Linux 提供了一个叫做 tee 的命令，这个命令制造了一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：ls &#x2F;usr&#x2F;bin | tee ls.txt | grep zip</p>
<p>(字符)展开 路径名展开 波浪线展开 算术表达式展开 花括号展开 参数展开 命令替换</p>
<p>引用 双引号 单引号 转义字符</p>
<p>在算术表达式中空格并不重要，并且表达式可以嵌套。一对括号可以用来把多个子表达式括起来。例如，5的平方乘以3：$(($((5<strong>2)) * 3)) &#x3D;&#x3D; $(((5</strong>2) * 3))</p>
<p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这种模式不能嵌入空白字符。echo Front-{A,B,C}-Back echo Number_{1..5} echo {Z..A} echo a{A{1,2},B{3,4}}b mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}</p>
<p>你可能注意到在其它展开类型中，如果你误输入一个模式，展开就不会发生。这时 echo 命令只简单地显示误键入的模式。但在参数展开中，如果你拼写错了一个变量名，展开仍然会进行，只是展开的结果是一个空字符串</p>
<p>命令替换允许我们把一个命令的输出作为一个展开模式来使用：ls -l $(which cp) &#x3D;&#x3D; ls -l <code>which cp</code></p>
<p>双引号。如果你把文本放在双引号中，shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。有几个例外： $，\ (反斜杠），和 &#96;（倒引号）。这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换仍然执行。使用双引号，我们可以处理包含空格的文件名。ls -l “two words.txt”</p>
<p>事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个虽然微妙但有趣的影响。考虑下面的例子：echo $(cal) !&#x3D; echo “$(cal)”，在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中，命令行只有一个参数，参数中包括嵌入的空格和换行符。</p>
<p>如果需要禁止所有的展开，我们要使用单引号。 echo text ~&#x2F;.txt {a,b} $(echo foo) $((2+2)) $USER echo “text ~&#x2F;.txt {a,b} $(echo foo) $((2+2)) $USER” echo ‘text ~&#x2F;*.txt {a,b} $(echo foo) $((2+2)) $USER’ 正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。</p>
<p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。经常在双引号中使用转义字符，来有选择地阻止展开。</p>
<p>命令行最为珍视的目标之一就是懒惰；用最少的击键次数来完成最多的工作。另一个目标是你的手指永远不必离开键盘，永不触摸鼠标。</p>
<p>表9-1: 光标移动命令</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">行动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl-a</td>
<td align="left">移动光标到行首。</td>
</tr>
<tr>
<td align="left">Ctrl-e</td>
<td align="left">移动光标到行尾。</td>
</tr>
<tr>
<td align="left">Ctrl-f</td>
<td align="left">光标前移一个字符；和右箭头作用一样。</td>
</tr>
<tr>
<td align="left">Ctrl-b</td>
<td align="left">光标后移一个字符；和左箭头作用一样。</td>
</tr>
<tr>
<td align="left">Alt-f</td>
<td align="left">光标前移一个字。</td>
</tr>
<tr>
<td align="left">Alt-b</td>
<td align="left">光标后移一个字。</td>
</tr>
<tr>
<td align="left">Ctrl-l</td>
<td align="left">清空屏幕，移动光标到左上角。clear 命令完成同样的工作。</td>
</tr>
</tbody></table>
<p>表9-2: 文本编辑命令</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">行动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl-d</td>
<td align="left">删除光标位置的字符。</td>
</tr>
<tr>
<td align="left">Ctrl-t</td>
<td align="left">光标位置的字符和光标前面的字符互换位置。</td>
</tr>
<tr>
<td align="left">Alt-t</td>
<td align="left">光标位置的字和其前面的字互换位置。</td>
</tr>
<tr>
<td align="left">Alt-l</td>
<td align="left">把从光标位置到字尾的字符转换成小写字母。</td>
</tr>
<tr>
<td align="left">Alt-u</td>
<td align="left">把从光标位置到字尾的字符转换成大写字母。</td>
</tr>
</tbody></table>
<p>表9-3: 剪切和粘贴命令</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">行动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl-k</td>
<td align="left">剪切从光标位置到行尾的文本。</td>
</tr>
<tr>
<td align="left">Ctrl-u</td>
<td align="left">剪切从光标位置到行首的文本。</td>
</tr>
<tr>
<td align="left">Alt-d</td>
<td align="left">剪切从光标位置到词尾的文本。</td>
</tr>
<tr>
<td align="left">Alt-Backspace</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Ctrl-y</td>
<td align="left">把剪切环中的文本粘贴到光标位置。</td>
</tr>
</tbody></table>
<p>表9-4: 自动补全命令</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">行动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Alt-?</td>
<td align="left">显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。</td>
</tr>
<tr>
<td align="left">Alt-*</td>
<td align="left">插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。</td>
</tr>
</tbody></table>
<p>历史命令展开 history | grep &#x2F;usr&#x2F;bin 88 ls -l &#x2F;usr&#x2F;bin &gt; ls-output.txt !88</p>
<p>bash 也具有增量搜索历史列表的能力。意思是在字符输入的同时，bash 会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入 Ctrl-r来启动增量搜索，接着输入你要寻找的字。当你找到它以后，你可以敲入 Enter 来执行命令，或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个匹配项（历史列表中向上移动）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。</p>
<p>表9-6: 历史展开命令</p>
<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!!</td>
<td align="left">重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。</td>
</tr>
<tr>
<td align="left">!number</td>
<td align="left">重复历史列表中第 number 行的命令。</td>
</tr>
<tr>
<td align="left">!string</td>
<td align="left">重复最近历史列表中，以这个字符串开头的命令。</td>
</tr>
<tr>
<td align="left">!?string</td>
<td align="left">重复最近历史列表中，包含这个字符串的命令。</td>
</tr>
</tbody></table>
<p>表10-1: 文件类型</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">文件类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-</td>
<td align="left">一个普通文件</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">一个目录</td>
</tr>
<tr>
<td align="left">l</td>
<td align="left">一个符号链接。注意对于符号链接文件，剩余的文件属性总是&quot;rwxrwxrwx&quot;，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。</td>
</tr>
</tbody></table>
<p>表 10-2: 权限属性</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">文件</th>
<th align="left">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">允许打开并读取文件内容。</td>
<td align="left">允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。</td>
<td align="left">允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。</td>
<td align="left">允许进入目录，例如：cd directory 。</td>
</tr>
</tbody></table>
<p>su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：su [-[l]] [user]。如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境，并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell，我们可以这样做：su -</p>
<p>以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：su -c ‘command’。使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想命令在我们的 shell 中展开，但需要在新 shell 中展开。</p>
<p>sudo 命令在很多方面都相似于 su 命令，但是 sudo 还有一些非常重要的功能。管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性）。另一个重要差异是 sudo 命令不要求超级用户的密码。使用 sudo 命令时，用户使用他&#x2F;她自己的密码来认证。</p>
<p>su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个用户的 shell 运行环境。这意味者命令不必用单引号引起来。注意通过指定各种各样的选项，这种行为可以被推翻。</p>
<p>只要输入 passwd 命令，就能更改你的密码。如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置另一个用户的密码。</p>
<p>默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。使用这个 “x” 选项，可以看到我们所拥有的每个进程的信息。</p>
<p>表11-1: 进程状态</p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R</td>
<td align="left">运行中。这意味着，进程正在运行或准备运行。</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">不可中断睡眠。进程正在等待 I&#x2F;O，比方说，一个磁盘驱动器的 I&#x2F;O。</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">已停止。 已经指示进程停止运行。稍后介绍更多。</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。</td>
</tr>
<tr>
<td align="left">N</td>
<td align="left">低优先级进程。 一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。</td>
</tr>
</tbody></table>
<p>另一个流行的选项组合是 “aux”（不带开头的”-“字符）。这会给我们更多信息：</p>
<p>表11-2: BSD 风格的 ps 命令列标题</p>
<table>
<thead>
<tr>
<th align="left">标题</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">USER</td>
<td align="left">用户 ID。 进程的所有者。</td>
</tr>
<tr>
<td align="left">%CPU</td>
<td align="left">以百分比表示的 CPU 使用率</td>
</tr>
<tr>
<td align="left">%MEM</td>
<td align="left">以百分比表示的内存使用率</td>
</tr>
<tr>
<td align="left">VSZ</td>
<td align="left">虚拟内存大小</td>
</tr>
<tr>
<td align="left">RSS</td>
<td align="left">进程占用的物理内存的大小，以千字节为单位。</td>
</tr>
<tr>
<td align="left">START</td>
<td align="left">进程启动的时间。若它的值超过24小时，则用天表示。</td>
</tr>
<tr>
<td align="left">top</td>
<td align="left">显示结果由两部分组成：最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。h，显示程序的帮助屏幕，q， 退出 top 程序。</td>
</tr>
</tbody></table>
<p>表11-3: top 命令信息字段</p>
<table>
<thead>
<tr>
<th align="left">行号</th>
<th align="left">字段</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">top</td>
<td align="left">程序名。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">14:59:20</td>
<td align="left">当前时间。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">up 6:30</td>
<td align="left">这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">2 users</td>
<td align="left">有两个用户登录系统。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">load average:</td>
<td align="left">加载平均值是指，等待运行的进程数目，也就是说，处于可以运行状态并共享 CPU 的进程个数。 这里展示了三个数值，每个数值对应不同的时间段。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Tasks:</td>
<td align="left">总结了进程数目和这些进程的各种状态。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Cpu(s):</td>
<td align="left">这一行描述了 CPU 正在进行的活动的特性。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0.7%us</td>
<td align="left">0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">1.0%sy</td>
<td align="left">1.0%的 CPU 时间被用于系统（内核）进程。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0.0%ni</td>
<td align="left">0.0%的 CPU 时间被用于&quot;nice&quot;（低优先级）进程。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">98.3%id</td>
<td align="left">98.3%的 CPU 时间是空闲的。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">0.0%wa</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Mem:</td>
<td align="left">展示物理内存的使用情况。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Swap:</td>
<td align="left">展示交换分区（虚拟内存）的使用情况。</td>
</tr>
</tbody></table>
<p>命令行启动程序，忘了在命令后加字符 “&amp;”， 将一个进程从前台移动到后台也是很方便的。输入 Ctrl-z，可以停止一个前台进程。用 bg 命令把程序移到后台。bg %1</p>
<p>表 11-4: 常用信号</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">名字</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">HUP</td>
<td align="left">挂起（Hangup）。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。</td>
</tr>
<tr>
<td align="left">许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>|2|	INT	|中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。<br>|9|	KILL|	杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。<br>|15	|TERM|	终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。<br>|18	|CONT|	继续。在一个停止信号后，这个信号会恢复进程的运行。<br>|19	|STOP|	停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</p>
<p>表 11-5: 其它常用信号</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">名字</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3</td>
<td align="left">QUIT</td>
<td align="left">退出</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">SEGV</td>
<td align="left">段错误(Segmentation Violation)。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">TSTP</td>
<td align="left">终端停止(Terminal Stop)。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">WINCH</td>
<td align="left">改变窗口大小(Window Change)。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</td>
</tr>
</tbody></table>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li>
        
      </ul>
    </div>

    
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://wanghuaren.github.io/2018/10/22/page22/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://wanghuaren.github.io/2018/10/22/page22/&text=The Linux Command Line"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://wanghuaren.github.io/2018/10/22/page22/&is_video=false&description=The Linux Command Line"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=The Linux Command Line&body=Check out this article: https://wanghuaren.github.io/2018/10/22/page22/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://wanghuaren.github.io/2018/10/22/page22/&title=The Linux Command Line"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://wanghuaren.github.io/2018/10/22/page22/&name=The Linux Command Line&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://wanghuaren.github.io/2018/10/22/page22/&t=The Linux Command Line"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    wnghuaren
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
